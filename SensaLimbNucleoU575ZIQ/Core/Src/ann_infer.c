// ANN inference starter
#include "ann_infer.h"

#include <string.h>

// Generated by X-CUBE-AI
#include "network.h"
#include "network_data.h"

// Quantization params from network_generate_report.txt
#define ANN_IN_SCALE      (0.003801456f)
#define ANN_IN_ZERO       (-128)
#define ANN_OUT_SCALE     (0.00390625f)
#define ANN_OUT_ZERO      (-128)

static ai_handle g_network = AI_HANDLE_NULL;
static ai_u8 g_activations[AI_NETWORK_DATA_ACTIVATIONS_SIZE];
static ai_i8 g_in_data[AI_NETWORK_IN_1_SIZE_BYTES];
static ai_i8 g_out_data[AI_NETWORK_OUT_1_SIZE_BYTES];

void ann_init(void) {
    ai_network_params params;
    if (!ai_network_data_params_get(&params)) {
        return;
    }
    params.activations = ai_network_data_activations_buffer_get(g_activations);
    params.weights = ai_network_data_weights_buffer_get(ai_network_data_weights_get());
    if (ai_network_create(&g_network, AI_NETWORK_DATA_CONFIG) != AI_ERROR_NONE) {
        g_network = AI_HANDLE_NULL;
        return;
    }
    if (!ai_network_init(g_network, &params)) {
        g_network = AI_HANDLE_NULL;
    }
}

static ai_i8 quantize_input(float v) {
    int q = (int)(v / ANN_IN_SCALE) + ANN_IN_ZERO;
    if (q < -128) q = -128;
    if (q > 127) q = 127;
    return (ai_i8)q;
}

float ann_predict(const float *features, size_t channels, size_t samples, float angle_value) {
    if (!g_network || !features) return 0.0f;

    // Expect 1x200x3 int8 input from report (size 600 bytes).
    // Layout: timesteps x 3 channels (EMG1, EMG2, angle history).
    const size_t input_steps = AI_NETWORK_IN_1_HEIGHT;
    const size_t input_ch = 3;
    if (samples != input_steps || channels != 2) {
        return 0.0f;
    }

    for (size_t t = 0; t < input_steps; t++) {
        g_in_data[t * input_ch + 0] = quantize_input(features[0 * samples + t]);
        g_in_data[t * input_ch + 1] = quantize_input(features[1 * samples + t]);
        // Normalize angle (0..160 deg -> 0..1)
        float angle_norm = angle_value / 160.0f;
        g_in_data[t * input_ch + 2] = quantize_input(angle_norm);
    }

    ai_buffer ai_input = AI_BUFFER_INIT(
        AI_BUFFER_FORMAT_S8,
        1, 1, AI_NETWORK_IN_1_SIZE, 1,
        g_in_data);

    ai_buffer ai_output = AI_BUFFER_INIT(
        AI_BUFFER_FORMAT_S8,
        1, 1, AI_NETWORK_OUT_1_SIZE, 1,
        g_out_data);

    if (ai_network_run(g_network, &ai_input, &ai_output) != 1) {
        return 0.0f;
    }

    ai_i8 q = g_out_data[0];
    float y = (float)(q - ANN_OUT_ZERO) * ANN_OUT_SCALE;
    // Map normalized output [0..1] to degrees [0..160]
    float angle_deg = y * 160.0f;
    return angle_deg;
}
